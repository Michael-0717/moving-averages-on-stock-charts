# Скользящие средние на биржевых графиках
## Задание: 
Используя данные индекса РТС за последние годы
https://video.ittensive.com/python-advanced/rts-index.csv
постройте отдельные графики закрытия (Close) индекса по дням за 2017, 2018, 2019 годы в единой оси X.
Добавьте на график экспоненциальное среднее за 20 дней для значения Max за 2017 год.
Найдите последнюю дату, когда экспоненциальное среднее максимального дневного значения (Max) в 2017 году было больше, чем соответствующее значение Close в 2019 году (это последнее пересечение графика за 2019 год и графика для среднего за 2017 год).
После какого дня 2019 года индекс РТС по закрытию окончательно 
___
## Решение:
1) Подключим необходимые библиотеки и загрузим данные.
2) Приведем все данные к дням года, чтобы отобразить на единой оси Х, заполним промежутки и затем нанесем все данные на один график и графически посмотрим на решение этой задачи.
3) Загрузим данные и посмотрим на них: - есть две сложности -  нужно привести дату строку к дате (времени) и развернуть данные в обратном порядке (нужно сначала самые старые).
4) Создадим дату строки, дополнительно укажем параметр dayfirst, чтобы все даты корректно отобразились из русского формата в английский.
5) Проиндексируем все данные  и заполним пустые даты предыдущими значениями. Это потребуется для сравнения серий данных по годам, чтобы в каждый день года у нас было хотя бы одно значение.
6) Добавим еще одну серию данных – день года по осям Х.
7) Назначим название индекса, которое потерялось при переиндексации.
8) Отсортируем по индексу чтобы развернуть данные в правильном хронологическом порядке.
9) Всё готово для нанесения данных на график. Начнет с данных за 2019 год, создадим для них отдельный набор, чтобы в последствии искать искомую дату превышения – как пересечение его с набором с 2017 годом.
10) Аналогично создадим для 2017 года, для него сразу возьмем экспозиционное среднее со сдвигом 20 от значения макс.
11) Нанесем обычные данные за 2017 год и за 2018 год в виде еще одной линии.
12) Добавим легенду с подписями данных.
13) Отфильтруем данные за 2019 год, когда Close (закрытие дня) было больше максимума аналогичного дня за 2017 год.
14) Выставим индекс по дате, отсортируем по индексу и выведем первое значение, т.е. последнюю дату когда дневной максимум в 2017 году был больше закрытия в соответсвующем дне 2017 года.


